
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ff first
#define ss second
#define pll pair<ll, ll>
#define pyramid priority_queue <ll, vector<ll>, greater<ll> >
#define ulta_pyramid priority_queue <ll>

#define all(a) (a).begin(),(a).end()
#define rall(a) (a).rbegin(),(a).rend()
#define sort_and_unique(a) sort(all(a));(a).resize(unique(all(a))-(a).begin())
#define outrange(x,min,max) ((x)<(min) || (x)>(max))
 
string DecimalToBinary(ll num);
 
void SieveOfEratosthenes(ll n,set<ll>&v);
 
ll power(ll x, ll y, ll p);
 
unsigned long long modInverse(unsigned long long n, int p);
 
unsigned long long nCrModPFermat(unsigned long long n,int r, int p);
 
long long lcm(ll a, ll b);
 
// returns -1 if s1 is not a substring of s2
int isSubstring(string s1, string s2);
 
const ll N=1e9+7;

struct prob{
    int s, t, d;
};

struct pro
{
    // set<pair<ll, ll>, prob> s;
    // set heap, with maxlen -> y-x at top
    bool operator()(const pair<ll, ll> &a, const pair<ll, ll> &b) const
    {
        ll d_a = a.second - a.first - 1;
        ll d_b = b.second - b.first - 1;
        if (d_a == d_b)
        {
            return a.first < b.first;
        }
        return d_a > d_b;
    }
};

int solve(){
    int n;
    cin>>n;
    string s;
    cin>>s;
    int cnt = 0;
    char start = s[0];
    for(int i = 0; i < n-1; i++){
        char next = s[i+1];
        if(start == next){
            cnt++;
            // i++;
        }
        else{
            start = next;
        }
    }
    cout << cnt << endl;
    return 0;
}

bool cmp(prob a, prob b){
    return ((a.t)*(b.d) < (b.t)*(a.d));
}

int main()
{

    ios_base ::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    int t;
    // cin>>t;
    t = 1;
    while(t--){
        solve();
    }
    cerr<<"Time:"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<"ms"<<endl;

    return 0;
}

ll power(ll x, ll y, ll p)// binaryExponentiation
{
    ll res = 1;
 
    while (y > 0) {
 
        if (y % 2 == 1)
            res = ((res%p) * (x%p))%p;
 
        y = y >> 1;
 
        x = ((x%p) * (x%p))%p;
    }
    return res % p;
}
unsigned long long modInverse(unsigned long long n,int p)
{
    return power(n, p - 2, p);
}
 
unsigned long long nCrModPFermat(unsigned long long n,int r, int p)
{
    if (n < r)
        return 0;
 
    if (r == 0)
        return 1;
 
    unsigned long long fac[n + 1];
    fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % p;
 
    return (fac[n] * modInverse(fac[r], p) % p
            * modInverse(fac[n - r], p) % p)
           % p;
}

void SieveOfEratosthenes(ll n,set<ll>&v)
{
    bool prime[n + 1];
    memset(prime, true, sizeof(prime));
 
    for (ll p = 2; p * p <= n; p++) {
        if (prime[p] == true) {
            for (ll i = p * p; i <= n; i += p){
                prime[i] = false;
            }
        }
    }
 
    for (ll p = 2; p <= n; p++){
        if (prime[p]){
            v.insert(p);
        }
    }
        
}
 
string DecimalToBinary(ll num)
{
    string str;
    if(num==0)
        return 0;
    while(num)
    {
        if(num & 1)
            str+='1';
        else
            str+='0';
          num>>=1;
    }   
    string s = str;
    reverse(all(s));
    return s;
}
 
int isSubstring1(char* s1, char* s2)
{
    int M = strlen(s1);
    int N = strlen(s2);
 
    for (int i = 0; i <= N - M; i++) {
        int j;
        for (j = 0; j < M; j++)
            if (s2[i + j] != s1[j])
                break;
 
        if (j == M)
            return i;
    }
 
    return -1;
}

// function to get the index of s2 in s1
int isSubstring(string s1, string s2)
{
    // using find method to check if s1 is
    // a substring of s2
    if (s2.find(s1) != string::npos)
        return s2.find(s1);
    return -1;
}

long long lcm(ll a, ll b)
{
    return (a / __gcd(a, b)) * b;
}
