/*                      ________________________
                       /      #
                      /     #   #
                     /        #
                    /
                   /       #   #
                  /      #        #
                 /                 #
                /                  #
               /                   #
              /                   #
             /                   #
\           /                   #
 \         /                  #
  \       /                 #
   \     /                 #
    \   /                 #       #
     \ /                    #   #
*/
//#pragma GCC optimize("Ofast")
//#pragma GCC target("avx,avx2,fma")
//#pragma GCC optimization("unroll-loops")

#include <bits/stdc++.h>
#include <complex>
using namespace std;
const long double PI = 3.1415926535897932384626;
typedef long long ll;
typedef vector<ll> vli;
typedef pair<ll, ll> pii;
#define f first
//#define s second
#define pb push_back
#define mp make_pair
#define rep(i, a, b) for (long long int i = a; i < b; i++)
//#define fill(a, b) memset(a, b, sizeof(a))
#define mod 1000000007

#define FIO                       \
    ios_base::sync_with_stdio(0); \
    cin.tie(0);                   \
    cout.tie(0);


//void fuck()
//{
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//}

/*
------>do anything but don't stop..don't procastinate...
------>make test cases for n=1,n=0...baoundary cases..
*/

////bool get_ans(ll aux)
////{
////
////}
bool collinear(int x1, int y1, int x2, int y2, int x3, int y3)
{
    return (y1 - y2) * (x1 - x3) != (y1 - y3) * (x1 - x2);
}
bool isInt(double num)
{
    return (num == (int)num);
}
//returns the minimum of two numbers
//ll min(ll x, ll y)
//{
//    return y ^ ((x ^ y) & -(x < y));
//}
////returns the maximum of two numbers
//ll max(ll x, ll y)
//{
//    return x ^ ((x ^ y) & -(x < y));
//}
//addition of two integers
//int add(int a, int b)
//{
//    if (b == 0)
//        return a;
//    int sum = a ^ b;
//    int carry = (a & b) << 1;
//    return add(sum, carry);
//}
//iterative addition of two integers
//int Add(int a, int b)
//{
//    while (b != 0)
//    {
//        int sum = a ^ b;
//        int carry = (a & b) << 1;
//        a = sum;
//        b = carry;
//    }
//    return a;
//}
//recursive subtraction of two integers
//int subtract(int a, int b)
//{
//    if (b == 0)
//        return a;
//    return subtract((a ^ b), ((~a) & b) << 1);
//}
//iterative subtraction of two integers
//int Subtract(int x, int y)
//{
//    while (y != 0)
//    {
//        int borrow = (~x) & y;
//        x = x ^ y;
//        y = borrow << 1;
//    }
//    return x;
//}
// Russian Peasant using bitwise operator
//multiplication function without using "*"
//int multiply(int a, int b)
//{
//    int res = 0;
//    while (b)
//    {
//        if (b & 1)
//        {
//            res = res + a;
//        }
//        a = a << 1;
//        b = b >> 1;
//    }
//    return res;
//}
//divide
//int divide(int a, int b)
//{
//    int sign = ((a < 0) ^ (b < 0)) ? -1 : 1;
//    a = abs(a);
//    b = abs(b);
//    int q = 0, tmp = 0;
//    for (int i = 31; i >= 0; --i)
//    {
//        if (tmp + (b << i) <= a)
//        {
//            tmp += (b << i);
//            q |= (1LL << i);
//        }
//    }
//    return sign * q;
//}
//O(sqrt(n)) for below
//ll phi(ll n)
//{
//    ll res = n;
//    for (ll i = 2; i * i <= n; i++)
//    {
//        if (n % i == 0)
//        {
//            res = res / i;
//            res = res * (i - 1);
//        }
//        while (n % i == 0)
//        {
//            n = n / i;
//        }
//    }
//
//    if (n > 1)
//    {
//        res = res * (n - 1);
//        res = res / n;
//    }
//    return res;
//}

//o(nlog(logn)) for below
//ll phi[1000006];
//void PHI()
//{
//    rep(i, 0, 1000006)
//    {
//        phi[i] = i;
//    }
//    rep(i, 2, 1000006)
//    {
//        if (phi[i] == i)
//        {
//            for (int j = i; j < 1000006; j = j + i)
//            {
//                phi[j] = phi[j] * (i - 1);
//                phi[j] = phi[j] / i;
//            }
//        }
//    }
//}
// prefix function in better way
//vector<int> prefix_func(string s)
//{
//    ll n=s.length();
//    vector<int> prefix(n,0);
//    prefix[0]=0;
//    int j=0;
//    for(int i=1;i<n;i++)
//    {
//        j=prefix[i-1];
//        while(j>0 && s[i]!=s[j])
//        {
//            j--;
//        }
//        if(s[i]==s[j])
//        {
//            j++;
//        }
//        prefix[i]=j;
//    }
//
//return prefix;
//}
//int kmp(string s,string pat)
//{
//    //string s="abaaba";
//    vector<int> prefix=prefix_func(s);
//    //for(auto i:prefix)
//    //{
//    //    cout<<i<<"   ";
//    //}
//    //cout<<endl;
//    //string pat="aa";
//    ll n=s.size();
//    ll j=0;
//    ll pos=0;
//    for(int i=0;i<n;i++)
//    {
//        if(s[i]==pat[j])
//        {
//            i+=1;
//            j+=1;
//        }
//        else
//        {
//            if(j>0)
//            {
//                j=prefix[j-1];
//            }
//            else
//            {
//                i++;
//            }
//        }
//        if(j==pat.size())
//        {
//            //cout<<i<<endl;
//            pos=i-pat.size();
//            break;
//        }
//    }
//    //cout<<pos<<endl;
//    return pos;
//}
//vector<int> get_z(string s)
//{
//    /*
//    isme kya hota h ki z array k kisi v index pr jo value hoti h wo ye btati h ki
//    uss index se utne length(uss index ki value) ki prefix exist krti h string me...
//    example-
//            string str=" a b c d s j v j a b c h j"
//                     Z=                  3
//                     yha jo 3 h wo bta rha h ki abc 3 length ki as a prefix exist krti h...
//    */
///*
//        jo isme [l,r] hai wo ye bta rha h ki "l" to "r" ki jo substring hai prefix k
//        barabar ho chuki h...
//
//        */
//    int n=s.length();
//    //int z[n];
//    vector<int> z(n,0);
//    //for(int i=0;i<n;i++)
//    //{
//    //    cout<<z[i]<<"  ";
//    //}
//    //memset(z,0,n);
//    int l=0,r=0;
//    for(int i=0;i<n;i++)
//    {
//        if(i>r)
//        {
//            l=r=i;
//            while(r<n && s[r-l]==s[r])
//            {
//                r=r+1;
//            }
//            z[i]=r-l;
//            r--;
//        }
//        else
//        {
//            int idx=i-l;
//            if(z[idx]+i<=r)
//            {
//                z[i]=z[idx];
//            }
//            else
//            {
//                l=i;
//                while(r<n && s[r-l]==s[r])
//                {
//                    r++;
//                }
//                z[i]=r-l;
//                r--;
//            }
//        }
//    }
//    return z;
//}
//to get better results in decimal places..
//use double for better precision in decimal places
//cout<<fixed<<setprecision(10)<<ans<<endl;
//we get double/float as return in sqrt(blah_blah) function
// find euclidean distance
double euclid_dist(ll x1, ll y1, ll x2, ll y2)
{
    return sqrt(abs(x1 - x2) * abs(x1 - x2) * 1.000 + abs(y1 - y2) * abs(y1 - y2) * 1.000);
}

ll binpow(ll a, ll b)
{
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}

ll binpow_mod(ll a, ll b, ll MOD)
{
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
        {
            res = ((res % MOD) * (a % MOD)) % MOD;
        }
        b = b >> 1;
        a = ((a % MOD) * (a % MOD)) % MOD;
    }
    return res;
}

//***function to check whether a str2 is a substring of str1 or not.....
//bool check_substring(string str1,string str2)
//{
//    ll pos=0;
//    for(ll i=0;i<str1.size();i++)
//    {
//        if(str1[i]==str2[pos])
//        {
//            pos++;
//        }
//        if(pos==str2.size())
//        {
//            break;
//        }
//    }
//    if(pos==str2.size())
//    {
//        return true;
//    }
//    return false;
//}
//function to count the occurence of a character in string
//ll count_occurence(string str,char search)
//{
//    ll ans=0;
//    for(int i=0;i<str.size();i++)
//    {
//        if(search==str[i])
//        {
//            ans=ans+1;
//        }
//    }
//    return ans;
//}
//vector<ll> get_factors(ll n)
//{
//    vector<ll> v;
//    for (int i = 1; i <= sqrt(n); i++)
//    {
//        if (n % i == 0)
//        {
//            if (n / i == i)
//            {
//                v.push_back(i);
//            }
//            else
//            {
//                v.push_back(i);
//                v.push_back((n / i));
//            }
//        }
//    }
//    return v;
//}
//----convert a number(as string) to any base
//int convert(string s,int base)
//{
//    int pw=1;
//    int n=0;
//    for(int i=n-1;i>=0;i--)
//    {
//        if(val(s[i])>base)
//        {
//            return INT_MAX;
//        }
//        n=n+(val[s[i]])*base;
//        pw=pw*base;
//    }
//    return n;
//}

//GRAPH DFS---------------GRAPH ALGOS BELOW THIS-------
//vector<int> graph[(int)102];
//bool visited[105];
//bool flag = false;
//void dfs(int start, int finish)
//{
//    visited[start] = true;
//    if (start == finish)
//    {
//        flag = true;
//        return;
//    }
//    for (auto i : graph[start])
//    {
//        if (!(visited[i]))
//        {
//            dfs(i, finish);
//        }
//    }
//}
//class DisjSet
//{
//    //complexity 4*alpha...most optimised version
//    int *rank, *parent, n;
//
//public:
//    DisjSet(int n)
//    {
//        size = new int[n];
//        parent = new int[n];
//        this->n = n;
//        makeSet();
//    }
//
//    void makeSet()
//    {
//        for (int i = 0; i < n; i++)
//        {
//            parent[i] = i;
//            size[i] = 1;
//        }
//    }
//
//    int find(int i)
//    {
//        if (i == parent[i])
//        {
//            return parent[i];
//        }
//        return parent[i] = find(parent[i])
//    }
//
//    void Union(int u, int v)
//    {
//        int paru = find(x);
//        int parv = find(y);
//
//        if (paru ^ parv)
//        {
//            if (size[parv] > size[paru])
//            {
//                //bade me chote ko add krenge
//                size[parv] += size[paru];
//                parent[paru] = parv;
//            }
//            else
//            {
//                size[paru] += size[parv];
//                parent[parv] = paru;
//            }
//        }
//    }
//};
//ll binary_search(vector<ll> &vec, ll val)
//{
//    ll left = 0, right = vec.size() - 1;
//    while (left <= right)
//    {
//        ll mid = (left + right) / 2;
//        if (vec[mid] == val)
//        {
//            return mid;
//        }
//        else if (vec[mid] < val)
//        {
//            left = mid + 1;
//        }
//        else
//        {
//            right = mid - 1;
//        }
//    }
//    return right; //this will return a number jus less than 'val'
//}

string convert_binary(ll n)
{
    string str = "";
    while (n)
    {
        if (n & 1)
        {
            str.push_back('1');
        }
        else
        {
            str.push_back('0');
        }
        n = n / 2;
    }
    reverse(str.begin(), str.end());
    return str;
}
//vector<ll> ans, bag(2, 0);

//2-d dfs waha tk chlana h jb tk feasible hp movement mtlb hm return tb hi honge jb out
// of bound ki condition aayegi
//int cnates[1000][2];
//bool visi[1000];
//vector<ll> adj[105];
//void dfs(ll src)
//{
//    visi[src] = true;
//    for (auto i : adj[src])
//    {
//        if (!visi[i])
//        {
//            dfs(i);
//        }
//    }
//}
//----------------------------------------------
//const int N = 1e6 + 3;
//bool prime[N];
//vector<ll> det(N, 0);
//void seive(int n)
//{
//    memset(prime, true, sizeof(prime));
//    prime[0] = false;
//    prime[1] = false;
//    for (int i = 2; i <= n; i++)
//    {
//        if (prime[i])
//        {
//            for (int j = 2 * i; j <= n; j += i)
//            {
//                prime[j] = false;
//            }
//        }
//    }
//    for (int i = 1; i < N; i++)
//    {
//        if (prime[i])
//        {
//            det[i] = det[i - 1];
//        }
//        else
//        {
//            det[i] = 1 + det[i - 1];
//        }
//    }
//}
/////////=-------------------------TARJAN's algorithm=-------------------O(V+E)////////
//vector<int> adj[100010];
//ll mini = INT_MAX;
//ll cnt, tot,ans;
//ll cst[100005];
//void dfs_for_tarjan(int u, vector<int> &disc, vector<int> &low, vector<bool> &instack, stack<int> &mystk)
//{
//    static int time = 0;
//    disc[u] = low[u] = time;
//   // cout<<time<<endl;
//    time = time + 1;
//    mystk.push(u);
//    instack[u] = true;
//    for (auto v : adj[u])
//    {
//        if (disc[v] == -1) //If nodes are not discovered yet
//        {
//            dfs_for_tarjan(v, disc, low, instack, mystk);
//            low[u] = min(low[u], low[v]);
//        }
//        else if (instack[v]) //it will be true when there will be a case of back edge
//        {
//            low[u] = min(low[u], disc[v]);
//        }
//    }
//    mini=INT_MAX;
//    if (disc[u] == low[u]) //IF u is head node of SCC
//    {
//        cnt=0;
//        //cout << "THE SCC IS:\n";
//        while (mystk.top() != u)
//        {
//            //  cout << mystk.top() << "  ";
//            if (cst[mystk.top()] < mini)
//            {
//                mini = cst[mystk.top()];
//                cnt = 0;
//            }
//            if (mini == cst[mystk.top()])
//            {
//                cnt = cnt + 1;
//            }
//            instack[mystk.top()] = false;
//            mystk.pop();
//        }
//        //cout << mystk.top() << "\n";
//        //cout<<ans<<" "<<tot<<endl;
//        if (cst[mystk.top()] < mini)
//        {
//            mini = cst[mystk.top()];
//            cnt = 0;
//        }
//        if (mini == cst[mystk.top()])
//        {
//            cnt = cnt + 1;
//        }
//        //cout<<cnt<<endl;
//        instack[mystk.top()] = false;
//        mystk.pop();
//        ans=ans+mini;
//        tot=((tot%mod)*(cnt%mod))%mod;
//        //cout<<ans<<" "<<tot<<endl;
//    }
//}
//void get_SCC_tarjan(int V)
//{
//    vector<int> disc(V+1, -1), low(V+1, -1);
//    vector<bool> instack(V+1, false);
//    stack<int> mystk;
//    for (int i = 1; i <= V; i++)
//    {
//        if (disc[i] == -1)
//        {
//            dfs_for_tarjan(i, disc, low, instack, mystk);
//        }
//    }
//}
//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
//-----------------------------DFS FOR TREE------------------------------------------
//-----------------------------------------------------------------------------------
//const int maxn = 100005;
//vector<ll> adj[maxn];
//vector<bool> visited(maxn, 0);
//ll dp[maxn];
//ll ok;  //
//ll ans; //
//ll a[maxn];
//void dfs(int curr, int par, int cnt)
//{
//    if (visited[curr])
//    {
//        return;
//    }
//    visited[curr] = true;
//
//    //if (par != -1)
//    //{
//    //    dp[curr] = dp[par] + 1;
//    //}
//    for (ll i = 0; i < adj[curr].size(); i++)
//    {
//        ll next = adj[curr][i];
//        if (par != next)
//        {
//            if (a[next] == 1 && a[curr] == 1)
//            {
//                dfs(next, curr, cnt + 1);
//            }
//            else
//            {
//                dfs(next, curr,a[next]);
//            }
//        }
//    }
//}
//----------------------------------------------------------------------------------
//------------------------------------BFS----------------------------------------------
//const int maxn = 20000;
//vector<ll> adj[maxn];
//ll ans[100000];
//vector<bool> visited(100000, 0);
//bool flag=false;
//void bfs(int i, int j)
//{
//    queue<ll> q;
//    q.push(i);
//    ans[i]=0;
//    while (!(q.empty()))
//    {
//        ll src = q.front();
//        q.pop();
//       //cout<<src<<" ";
//        for (auto ii : adj[src])
//        {
//            if (!(visited[ii]))
//            {
//                visited[ii]=true;
//                ans[ii]=ans[src]+1;
//                q.push(ii);
//                if (ii == j)
//                {
//                    flag = true;
//                    break;
//                }
//            }
//        }
//        if(flag)
//        {
//            break;
//        }
//    }
//    //cout<<"\n";
//    return;
//}
//-----------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------
//--------------------------------LCS------------------------------------------------
//ll dp[5005][5005];
//ll lcs(string s1,string s2)
//{
//    for(int i=0;i<s1.size();i++)
//    {
//        dp[0][i]=0;
//    }
//    for(int i=0;i<s2.size();i++)
//    {
//        dp[i][0]=0;
//    }
//    for(int i=1;i<=s1.size();i++)
//    {
//        for(int j=1;j<=s2.size();j++)
//        {
//            if(s1[i-1]==s2[j-1])
//            {
//                dp[i][j]=dp[i-1][j-1]+1;
//            }
//            else
//            {
//                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
//            }
//        }
//    }
//
//    //printing of lcs
//    string ans;
//    int i=s1.size();
//    int j=s2.size();
//    while(i>0 && j>0)
//    {
//        if(s1[i-1]==s2[j-1])
//        {
//            ans.push_back(s1[i-1]);
//            i--,j--;
//        }
//        else if(dp[i-1][j]>dp[i][j-1])
//        {
//            i--;
//        }
//        else
//        {
//            j--;
//        }
//    }
//    reverse(ans.begin(),ans.end());
//    cout<<ans<<"\n";
//    return dp[s1.size()][s2.size()];
//}
//vector<pair<int, int>> adj[100005];
//vector<int> v[100005];
//ll findshortest(int src, int n)
//{
//    ll dist[n + 1];
//    for (int i = 0; i <= n; i++)
//    {
//        dist[i] = INT_MAX;
//    }
//    dist[src] = 0;
//    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
//    pq.push({0, src});
//    while (!pq.empty())
//    {
//        auto node = pq.top().second;
//        auto dis = pq.top().first;
//        pq.pop();
//        //cout<<node<<"\n";
//        if(v[node].size())
//        {
//            while(binary_search(v[node].begin(),v[node].end(),dis))
//            {
//                dis++;
//            }
//        }
//        //cout<<"11\n";
//        for (auto it : adj[node])
//        {
//         //   cout<<it.first<<"  "<<it.second<<"\n";
//            if ((dis + it.second) < dist[it.first])
//            {
//                dist[it.first] = dis + it.second;
//                pq.push({dist[it.first], it.first});
//            }
//        }
//       // cout<<"123\n";
//    }
//    return dist[n];
//}
//vector<int> adj[200009];
//vector<int> height(200009, 0);
//vector<int> det_lev[200009];
//vector<int> out_degree(200009, -1);
//vector<int> parent(200009, 0);
//void dfs(int curr, int par, int level)
//{
//    parent[curr] = par;
//    height[curr] = level;
//    det_lev[level].push_back(curr);
//    out_degree[curr] = adj[curr].size() - 1;
//    for (auto it : adj[curr])
//    {
//        if (it != par)
//        {
//            dfs(it, curr, level + 1);
//        }
//    }
//    return;
//}
//bool mycomp(const pair<ll, ll> &a, const pair<ll, ll> &a)
//{
//    return a.first < b.second;
//}
//int reflec[10]={0,1,5,-1,-1,2,-1,-1,8,-1};//reflection of numbers in mirror
//const int INF = 1e9 + 7;
//const int maxn = 5e6 + 1;
//vector<int> prime_divisors_till(maxn, 0);
//void get_no_of_prime_divisors(vector<int> &prime_divisors_till, int maxn)
//{
//    vector<int> seive(maxn, 0);
//    vector<int> no_of_prime_divisors(maxn, 0);
//    for (int i = 2; i < maxn; i++)
//    {
//        if (seive[i] == 0)
//        {
//            for (int j = i; j < maxn; j = j + i)
//            {
//                seive[j] = i;
//            }
//        }
//        int p = seive[i];
//        no_of_prime_divisors[i] = 1 + no_of_prime_divisors[i / p];
//        prime_divisors_till[i] += no_of_prime_divisors[i] + prime_divisors_till[i - 1];
//    }
//}
//ll n;
//ll dp[2005][2005];
//bool fun(vector<ll> &subset,ll i,ll sum)
//{
//    if(i==0)
//    {
//        if(sum==0)
//        {
//            return true;
//        }
//        return false;
//    }
//    if(dp[i][sum]!=-1)
//    {
//        return dp[i][sum];
//    }
//    bool ans=false;
//    if(sum-subset[i-1]>=0)
//    {
//        ans|=fun(subset,i-1,sum-subset[i-1]);
//    }
//    ans|=fun(subset,i-1,sum);
//    return dp[i][sum]=ans;
//}
ll check(string str1, string str2)
{
    if (str2.find(str1) != string::npos)
    {
        return 1;
    }
    return 0;
}
ll findMex(vli arr, ll n)
{
    sort(arr.begin(), arr.end());
    if (arr[0] != 0)
        return 0;
    rep(i, 1, n - 1)
    {
        if (arr[i] - arr[i - 1] <= 1)
            continue;
        return arr[i - 1] + 1;
    }
    return arr[n - 1] + 1;
}
const int maxn = 2e5 + 5;

vector<int> convert_string(ll a)
{
    vector<int> ans;
    ll b = a;
    while (b)
    {
        ans.push_back(b % 10);
        b /= 10;
    }
    return ans;
}

//vector<int> level(200005, 0);
//ll parent[200005][22];
//ll n, q;
//void dfs(int curr, int par, int h)
//{
//    level[curr] = h;
//    if (par != -1)
//    {
//        parent[curr][0] = par;
//    }
//    for (auto it : adj[curr])
//    {
//        if (it != par)
//        {
//            dfs(it, curr, h + 1);
//        }
//    }
//}
//void preprocess_lca()
//{
//    dfs(1, -1, 1);
//
//    for (int j = 1; j <= 21; j++)
//    {
//        //cout<<parent[i][0]<<" ";
//        for (int i = 1; i <= n; i++)
//        {
//            parent[i][j] = parent[parent[i][j - 1]][j - 1];
//            //  cout<<parent[i][j]<<" ";
//        }
//        //cout<<"\n";
//    }
//}
//
//void query(ll x, ll k)
//{
//    int cnt = 0;
//    while (k)
//    {
//        if (k & 1)
//        {
//            x = parent[x][cnt];
//        }
//        cnt += 1;
//        k = k >> 1;
//    }
//    if (x != 0)
//    {
//        cout << x << "\n";
//    }
//    else
////    {
////        cout << "-1\n";
////    }
////    return;
////}
vector<bool> prime;
void seive(int n)
{
    prime[0] = false;
    prime[1] = false;
    prime[2] = true;
    for (int i = 2; i * i <= n; i++)
    {
        if (prime[i])
        {
            for (int j = 2 * i; j <= n; j += i)
            {
                prime[j] = false;
            }
        }
    }
}

//int diameter = 0;
//vector<int> adj[200005];
//vector<int> dp1(200005, 0); //stores the value of max of l,r
//vector<int> dp2(200005, 0); //stores the value of 1+l+r
//void dfs_for_diameter(int curr, int par)
//{
//    vector<int> fvalues;
//    bool leaf = true;
//    for (auto it : adj[curr])
//    {
//        if (it == par)
//        {
//            continue;
//        }
//        leaf = false;
//        dfs_for_diameter(it, curr);
//        fvalues.push_back(dp1[it]);
//    }
//    if (leaf)
//    {
//        dp1[curr] = 0;
//        return;
//    }
//    sort(fvalues.begin(), fvalues.end());
//    dp1[curr] = 1;
//    if (!fvalues.empty())
//    {
//        dp1[curr] += fvalues.back();
//    }
//    if (fvalues.size() >= 2)
//    {
//        dp2[curr] = 2 + fvalues.back() + fvalues[fvalues.size() - 2];
//    }
//    diameter = max(diameter, max(dp1[curr], dp2[curr]));
//}
/*
int freq[26] = {0};
ll n, k;
string str;
ll even, odd;
bool check_bsa(int mid)
{
    ll ev = even, od = odd;
    for (int i = 0; i < k; i++)
    {
        if ((mid % 2) == 1)
        {
            if (od > 0)
            {
                od--;
                ev -= (mid - 1);
            }
            else
            {
                ev -= (mid + 1);
                od++;
            }
        }
        else
        {
            ev -= mid;
        }
    }
    if (ev < 0)
    {
        return false;
    }
    return true;
}
vector<int> convert_to_vec(string str)
{
    vector<int> v;
    for (auto it : str)
    {
        v.push_back(it - '0');
    }
    return v;
}


int vis[100005];
int dist[100005];
vector<pair<int,int>> adj[100005];
struct node
{
    int zero;
    int one;
};
*/
//ll sm;
//ll n,m,k;
//ll recur(ll i,ll k_aux,vector<ll> &weight)
//{
//    if(k_aux==k)
//    {
//        if(i==m)
//        {
//            return 1;
//        }
//        return 0;
//    }
//    ll pick=0,unpick=0;
//    for(int idx=i+1;i<n;i++)
//    {
//        pick+=((weight[idx]/sum)%mod)*(recur(idx+1,k_aux+1,weight))%mod)%mod;
//    }
//    pick+=((weight[idx]/sum)%mod)*(recur(idx,k_aux+1,weight))%mod)%mod;
//}
ll n,m,k;
vector<vector<vector<ll>>> dp;
vector<vector<ll>> r,d;
ll recur(int i,int j,int k)
{
    if(k==0)
    {
        return 0;
    }

    if(dp[i][j][k]!=-1)
    {
        return dp[i][j][k];
    }
    ll ans=LLONG_MAX;

    if(i-1>=0)
    {
        ans=min(ans,d[i-1][j]+recur(i-1,j,k-1));
    }
    if(i+1<n)
    {
        ans=min(ans,d[i][j]+recur(i+1,j,k-1));
    }
    if(j-1>=0)
    {
        ans=min(ans,r[i][j-1]+recur(i,j-1,k-1));
    }
    if(j+1<m)
    {
        ans=min(ans,r[i][j]+recur(i,j+1,k-1));
    }

    return dp[i][j][k]=ans;
}

void update(vector<ll> &fenwick,ll i,ll val)
{
    while(i<(int)fenwick.size())
    {
        fenwick[i]+=val;
        i+=(i&(-i));
    }
}
ll sum(vector<ll> &fenwick,ll i)
{
    ll sm=0;
    while(i>0)
    {
        sm+=(fenwick[i]);
        i-=(i&(-i));
    }
    return sm;
}
void solve()
{  
    ll n;
    cin>>n;
    ll res=0;
    while(n--)
    {
        string str;
        cin>>str;
        if(str=="++X"||str=="X++")
        {
            res+=1;
        }
        else
        {
            res-=1;
        }
    }
    cout<<res<<"\n";
}


int main()
{
    #ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
  #endif
    //FIO
    //freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
    //get_no_of_prime_divisors(prime_divisors_till, maxn);
    //ios::sync_with_stdio(false);
    //cin.tie(NULL); // Remove in problems with online queries!
    ll t;
    //scanf("%lld", &t);
    t = 1;
    //cin >> t;
    //vector<ll> val((int)1e6+7,0);
    //prime.resize(1000005,true);
    //seive(1000005);
    
    for (int i = 1; i <= t; i++)
    {
        
        //cout << "Case #" << i << ": ";
        solve();
    }

    return 0;
}
//std::fill(vec.begin(),vec.end(),1)
//dp me chote se bda leke jana h..
//An array d is a subarray of an array c if d can be obtained from c by deletion of
//several (possibly, zero or all)
//elements from the beginning and several (possibly, zero or all) elements from the end.
